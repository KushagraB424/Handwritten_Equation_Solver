<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equation Solver</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        .equation-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .drawing-area {
            flex: 1;
            max-width: 400px;
        }
        
        .equals-sign {
            font-size: 48px;
            font-weight: bold;
            padding: 0 20px;
        }
        
        canvas {
            background-color: white;
            border: 2px solid #ccc;
            border-radius: 5px;
            width: 100%;
            height: 200px;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            cursor: crosshair;
        }
        
        /* Make buttons more touch-friendly */
        button {
            padding: 12px 24px;
            font-size: 16px;
            min-width: 100px;
            min-height: 44px; /* Minimum touch target size */
            touch-action: manipulation;
        }
        
        /* Prevent text selection on double-tap */
        * {
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Draw Your Equation</h1>
        
        <div class="equation-container">
            <div class="drawing-area">
                <canvas id="leftCanvas"></canvas>
            </div>
            <div class="equals-sign">=</div>
            <div class="drawing-area">
                <canvas id="rightCanvas"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <button id="clearBtn">Clear</button>
            <button id="solveBtn">Solve</button>
        </div>

        <div class="result-area" id="resultArea" style="display: none;">
            <h2>Results</h2>
            <div class="equation-text" id="equationText"></div>
            <div class="solution-text" id="solutionText"></div>
        </div>

        <div class="loading" id="loading" style="display: none;">
            Solving equation...
        </div>

        <div class="error" id="errorMessage" style="display: none;"></div>
    </div>

    <script>
        function setupCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            // Set canvas size and initialize it
            function resizeCanvas() {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Initial setup
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            function getCanvasXY(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                
                if (e.touches && e.touches[0]) {
                    // For touch events
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                    
                    // Prevent scrolling when drawing near the edges
                    if (clientX < 20 || clientX > window.innerWidth - 20 ||
                        clientY < 20 || clientY > window.innerHeight - 20) {
                        return null;
                    }
                } else {
                    // For mouse events
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return [
                    (clientX - rect.left) * scaleX,
                    (clientY - rect.top) * scaleY
                ];
            }

            function startDrawing(e) {
                e.preventDefault();
                isDrawing = true;
                [lastX, lastY] = getCanvasXY(e);
            }

            function draw(e) {
                e.preventDefault();
                if (!isDrawing) return;
                
                const coords = getCanvasXY(e);
                if (!coords) return;
                
                const [x, y] = coords;
                
                // Draw a line from the last point to this one
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Draw a circle at the current point for better touch drawing
                ctx.beginPath();
                ctx.arc(x, y, ctx.lineWidth / 2, 0, Math.PI * 2);
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fill();
                
                [lastX, lastY] = [x, y];
            }

            function stopDrawing(e) {
                e.preventDefault();
                isDrawing = false;
            }

            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // Touch events with passive: false for better control
            const touchOptions = { passive: false };
            canvas.addEventListener('touchstart', startDrawing, touchOptions);
            canvas.addEventListener('touchmove', draw, touchOptions);
            canvas.addEventListener('touchend', stopDrawing, touchOptions);
            canvas.addEventListener('touchcancel', stopDrawing, touchOptions);
            
            // Prevent context menu on long press
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });
            
            // Handle window resize for better mobile experience
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    const currentLeft = canvas === document.getElementById('leftCanvas');
                    const currentImage = currentLeft ? leftCanvas.getImage() : rightCanvas.getImage();
                    resizeCanvas();
                    // Redraw the last drawing after resize
                    if (currentImage) {
                        const img = new Image();
                        img.onload = function() {
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        };
                        img.src = currentImage;
                    }
                }, 250);
            });

            return {
                clear: () => {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                },
                getImage: () => canvas.toDataURL('image/png')
            };
        }

        // Setup both canvases with touch support
        const leftCanvas = setupCanvas(document.getElementById('leftCanvas'));
        const rightCanvas = setupCanvas(document.getElementById('rightCanvas'));
        
        // Prevent scrolling when drawing on canvas
        document.body.addEventListener('touchmove', function(e) {
            if (e.target.tagName === 'CANVAS') {
                e.preventDefault();
            }
        }, { passive: false });

        // Clear both canvases
        document.getElementById('clearBtn').addEventListener('click', () => {
            leftCanvas.clear();
            rightCanvas.clear();
            document.getElementById('resultArea').style.display = 'none';
            document.getElementById('errorMessage').style.display = 'none';
        });

        // Solve equation
        document.getElementById('solveBtn').addEventListener('click', async () => {
            const loading = document.getElementById('loading');
            const errorMessage = document.getElementById('errorMessage');
            const resultArea = document.getElementById('resultArea');

            loading.style.display = 'block';
            errorMessage.style.display = 'none';
            resultArea.style.display = 'none';

            try {
                // Get image data from both canvases
                const leftImage = leftCanvas.getImage();
                const rightImage = rightCanvas.getImage();
                
                // Send to server
                const response = await fetch('/solve', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        leftImage: leftImage,
                        rightImage: rightImage
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Display results
                    const equationDisplay = (data.leftExpression && data.rightExpression)
                        ? `${data.leftExpression} = ${data.rightExpression}`
                        : data.equation;
                    document.getElementById('equationText').textContent = `Equation: ${equationDisplay}`;
                    document.getElementById('solutionText').textContent = 
                        `Solution: ${data.formatted_solution || 'No solution found'}`;

                    resultArea.style.display = 'block';
                } else {
                    errorMessage.textContent = data.error;
                    errorMessage.style.display = 'block';
                }
            } catch (error) {
                errorMessage.textContent = 'Error processing equation: ' + error.message;
                errorMessage.style.display = 'block';
            } finally {
                loading.style.display = 'none';
            }
        });
    </script>
</body>
</html>